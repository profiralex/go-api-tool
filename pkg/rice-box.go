// Code generated by rice embed-go; DO NOT EDIT.
package pkg

import (
	"time"

	"github.com/GeertJohan/go.rice/embedded"
)

func init() {

	// define files
	file3 := &embedded.EmbeddedFile{
		Filename:    "entities/entity.go.tpl",
		FileModTime: time.Unix(1608829508, 0),

		Content: string("/*Generated code do not modify it*/\npackage entities\n\nimport (\n\"context\"\n\"fmt\"\n\"github.com/gocraft/dbr/v2\"\n\"github.com/google/uuid\"\n\"time\"\n)\n\ntype Base{{plural .Model.Name}}Repo interface {\nFindById(ctx context.Context, id int64) ({{$.Model.Name}}, bool, error)\nFindByIds(ctx context.Context, ids ...int64) ([]{{$.Model.Name}}, error)\nFindByUuid(ctx context.Context, uuid string) ({{$.Model.Name}}, bool, error)\nFindByUuids(ctx context.Context, uuids ...string) ([]{{$.Model.Name}}, error)\n{{- range $i, $field := .Model.Fields}}\n    {{- if $field.HasConstraint \"foreign_key\"}}\n        FindBy{{$field.Name}}(ctx context.Context, {{toCamelCase $field.Name}} {{$field.GetGoType}}) ({{$.Model.Name}}, bool, error)\n        FindBy{{$field.Name}}s(ctx context.Context, {{toCamelCase $field.Name}}s ...{{$field.GetGoType}}) ([]{{$.Model.Name}}, error)\n    {{- end}}\n{{- end}}\nSave(ctx context.Context, records ...*{{$.Model.Name}}) error\nDelete(ctx context.Context, records ...*{{$.Model.Name}}) error\nDeleteByIds(ctx context.Context, ids ...int64) error\n}\n\ntype {{$.Model.Name}} struct {\n{{- range $i, $field := .Model.Fields}}\n    {{$field.Name}} {{$field.GetGoType}} `json:\"{{toSnakeCase $field.Name}}\" dbr:\"{{toSnakeCase $field.Name}}\"`\n{{- end}}\n}\n\nvar _ Base{{plural .Model.Name}}Repo = &{{$.Model.Name}}EntitiesManager{}\ntype {{$.Model.Name}}EntitiesManager struct {\ntable   string\nsession dbr.Session\n}\n\nfunc New{{$.Model.Name}}EntitiesManager(session dbr.Session) *{{$.Model.Name}}EntitiesManager {\nreturn &{{$.Model.Name}}EntitiesManager{\ntable:   \"{{getModelSqlTable .Model.Name}}\",\nsession: session,\n}\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) FindById(ctx context.Context, id int64) ({{$.Model.Name}}, bool, error) {\nreturn m.Query().IdEq(id).FindFirst(ctx)\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) FindByIds(ctx context.Context, ids ...int64) ([]{{$.Model.Name}}, error) {\nreturn m.Query().IdIn(ids).FindAll(ctx)\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) FindByUuid(ctx context.Context, uuid string) ({{$.Model.Name}}, bool, error) {\nreturn m.Query().UuidEq(uuid).FindFirst(ctx)\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) FindByUuids(ctx context.Context, uuids ...string) ([]{{$.Model.Name}}, error) {\nreturn m.Query().UuidIn(uuids).FindAll(ctx)\n}\n\n{{- range $i, $field := .Model.Fields}}\n    {{ if $field.HasConstraint \"foreign_key\"}}\n        func (m *{{$.Model.Name}}EntitiesManager) FindBy{{$field.Name}}(ctx context.Context, {{toCamelCase $field.Name}} {{$field.GetGoType}}) ({{$.Model.Name}}, bool, error) {\n        return m.Query().{{$field.Name}}Eq({{toCamelCase $field.Name}}).FindFirst(ctx)\n        }\n\n        func (m *{{$.Model.Name}}EntitiesManager) FindBy{{$field.Name}}s(ctx context.Context, {{toCamelCase $field.Name}}s ...{{$field.GetGoType}}) ([]{{$.Model.Name}}, error) {\n        return m.Query().{{$field.Name}}In({{toCamelCase $field.Name}}s).FindAll(ctx)\n        }\n    {{- end}}\n{{- end}}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) Save(ctx context.Context, records ...*{{$.Model.Name}}) error {\nvar recordsToInsert []*{{$.Model.Name}}\nvar recordsToUpdate []*{{$.Model.Name}}\n\nfor _, record := range records {\nif record.Id == 0 || record.CreatedAt.IsZero() || record.UpdatedAt.IsZero() {\nrecordsToInsert = append(recordsToInsert, record)\n} else {\nrecordsToUpdate = append(recordsToUpdate, record)\n}\n}\n\nfor _, record := range recordsToUpdate {\nerr := m.singleUpdate(ctx, record)\nif err != nil {\nreturn fmt.Errorf(\"failed to update record %d: %w\", record.Id, err)\n}\n}\n\nfor _, record := range recordsToInsert {\nerr := m.singleInsert(ctx, record)\nif err != nil {\nreturn fmt.Errorf(\"failed to insert record: %w\", err)\n}\n}\n\nreturn nil\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) singleUpdate(ctx context.Context, record *{{$.Model.Name}}) error {\nrecord.UpdatedAt = time.Now()\nerr := m.session.Update(m.table).\nSetMap(map[string]interface{}{\n{{- range $i, $field := .Model.Fields}}\n    {{- if and (ne $field.Name \"Id\") (ne $field.Name \"Uuid\") }}\n        \"{{toSnakeCase $field.Name}}\": record.{{$field.Name}},\n    {{- end}}\n{{- end}}\n}).\nWhere(\"id = ?\", record.Id).\nLoadContext(ctx, record)\n\nreturn err\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) singleInsert(ctx context.Context, record *{{$.Model.Name}}) error {\nrecord.Uuid = uuid.New().String()\nrecord.CreatedAt = time.Now()\nrecord.UpdatedAt = record.CreatedAt\n\n_, err := m.session.InsertInto(m.table).\nColumns(\n{{- range $i, $field := .Model.Fields}}\n    {{- if ne $field.Name \"Id\" }}\n        \"{{toSnakeCase $field.Name}}\",\n    {{- end}}\n{{- end}}\n).\nRecord(record).\nExecContext(ctx)\n\nreturn err\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) Delete(ctx context.Context, records ...*{{$.Model.Name}}) error {\nif len(records) == 0 {\nreturn nil\n}\n\nvar ids []int64\nfor _, record := range records {\nids = append(ids, record.Id)\n}\n\nreturn m.DeleteByIds(ctx, ids...)\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) DeleteByIds(ctx context.Context, ids ...int64) error {\n_, err := m.session.DeleteFrom(m.table).\nWhere(dbr.Eq(\"id\", ids)).\nExecContext(ctx)\n\nif err != nil {\nreturn fmt.Errorf(\"failed to delete records: %w\", err)\n}\n\nreturn nil\n}\n\ntype {{$.Model.Name}}EntitiesQuery struct {\nfilters      []dbr.Builder\noffset       *uint64\nlimit        *uint64\norderingAsc  []string\norderingDesc []string\ntable        string\nsession      dbr.Session\n}\n\nfunc (m *{{$.Model.Name}}EntitiesManager) Query() *{{$.Model.Name}}EntitiesQuery {\nreturn &{{$.Model.Name}}EntitiesQuery{\ntable:   m.table,\nsession: m.session,\n}\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) Limit(limit uint64) *{{$.Model.Name}}EntitiesQuery {\nq.limit = &limit\nreturn q\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) Offset(offset uint64) *{{$.Model.Name}}EntitiesQuery {\nq.offset = &offset\nreturn q\n}\n\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) FindAll(ctx context.Context) ([]{{$.Model.Name}}, error) {\nvar records []{{$.Model.Name}}\n_, err := q.computeSelectStatement().\nLoadContext(ctx, &records)\n\nif err != nil {\nreturn records, fmt.Errorf(\"failed to load records: %w\", err)\n}\n\nreturn records, nil\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) FindFirst(ctx context.Context) ({{$.Model.Name}}, bool, error) {\nrecords, err := q.Limit(1).FindAll(ctx)\nif err != nil {\nreturn {{$.Model.Name}}{}, false, fmt.Errorf(\"failed to get records: %w\", err)\n}\n\nif len(records) == 0 {\nreturn {{$.Model.Name}}{}, false, nil\n}\n\nreturn records[0], true, nil\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) Exists(ctx context.Context) (bool, error) {\n_, ok, err := q.FindFirst(ctx)\nif err != nil {\nreturn false, fmt.Errorf(\"failed to get first record: %w\", err)\n}\n\nreturn ok, nil\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) Count(ctx context.Context) (uint64, error) {\nresult := struct {\nCount uint64 `dbr:\"count\"`\n}{}\n\nerr := q.computeSelectStatement(\"COUNT(*) as count\").LoadOneContext(ctx, &result)\nif err != nil {\nreturn 0, fmt.Errorf(\"failed to retrieve records count: %w\", err)\n}\n\nreturn result.Count, nil\n}\n\nfunc (q *{{$.Model.Name}}EntitiesQuery) computeSelectStatement(columns ...string) *dbr.SelectStmt {\nif len(columns) == 0 {\ncolumns = append(columns, \"*\")\n}\n\nstmt := q.session.Select(columns...).From(q.table)\n\nif len(q.filters) == 1 {\nstmt = stmt.Where(q.filters[0])\n}\n\nif len(q.filters) > 1 {\nstmt = stmt.Where(dbr.And(q.filters...))\n}\n\nif q.limit != nil {\nstmt = stmt.Limit(*q.limit)\n}\n\nif q.offset != nil {\nstmt = stmt.Offset(*q.offset)\n}\n\nfor _, column := range q.orderingAsc {\nstmt = stmt.OrderAsc(column)\n}\n\nfor _, column := range q.orderingDesc {\nstmt = stmt.OrderDesc(column)\n}\n\nreturn stmt\n}\n\n{{- range $i, $field := .Model.Fields}}\n    func (q *{{$.Model.Name}}EntitiesQuery) OrderAscBy{{$field.Name}}() *{{$.Model.Name}}EntitiesQuery {\n    q.orderingAsc = append(q.orderingAsc, \"{{toSnakeCase $field.Name}}\")\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) OrderDescBy{{$field.Name}}() *{{$.Model.Name}}EntitiesQuery {\n    q.orderingAsc = append(q.orderingDesc, \"{{toSnakeCase $field.Name}}\")\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Eq(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Eq(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Neq(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Neq(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}In(values []{{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Eq(\"{{toSnakeCase $field.Name}}\", values))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Gt(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Gt(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Gte(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Gte(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Lt(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Lt(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Lte(value {{$field.GetGoType}}) *{{$.Model.Name}}EntitiesQuery {\n    q.filters = append(q.filters, dbr.Lte(\"{{toSnakeCase $field.Name}}\", value))\n    return q\n    }\n\n    {{- if eq $field.Type \"string\" }}\n        func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}Like(value string) *{{$.Model.Name}}EntitiesQuery {\n        q.filters = append(q.filters, dbr.Like(\"{{toSnakeCase $field.Name}}\", value))\n        return q\n        }\n\n        func (q *{{$.Model.Name}}EntitiesQuery) {{$field.Name}}NotLike(value string) *{{$.Model.Name}}EntitiesQuery {\n        q.filters = append(q.filters, dbr.NotLike(\"{{toSnakeCase $field.Name}}\", value))\n        return q\n        }\n    {{- end}}\n{{- end}}\n"),
	}
	file5 := &embedded.EmbeddedFile{
		Filename:    "logs/logs.go.tpl",
		FileModTime: time.Unix(1608827132, 0),

		Content: string("/*Generated code do not modify it*/\npackage logs\n\nimport (\n    log \"github.com/sirupsen/logrus\"\n)\n\nfunc Init(logLevel string) {\n    level, err := log.ParseLevel(logLevel)\n    if err != nil {\n        log.Warnf(\"Unknown log level %s defaulting to warning level\", logLevel)\n        level = log.WarnLevel\n    }\n\n    log.SetLevel(level)\n    log.SetFormatter(&log.JSONFormatter{})\n    log.SetReportCaller(true)\n}\n"),
	}
	file7 := &embedded.EmbeddedFile{
		Filename:    "server/response.go.tpl",
		FileModTime: time.Unix(1608825122, 0),

		Content: string("/*Generated code do not modify it*/\npackage server\n\nimport (\n\t\"github.com/go-chi/render\"\n\t\"github.com/go-playground/validator/v10\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net/http\"\n)\n\n// Response the struct to hold the common response field\ntype Response struct {\n\tData   interface{} `json:\"data\"`\n\tErrors []APIError  `json:\"errors\"`\n\tStatus int         `json:\"status\"`\n}\n\n// APIError holds response error information\ntype APIError struct {\n\tMessage   string `json:\"message\"`\n\tField     string `json:\"field\"`\n\tReference string `json:\"ref\"`\n}\n\nfunc (response *Response) Render(w http.ResponseWriter, r *http.Request) error {\n\trender.Status(r, response.Status)\n\tif response.Status == 500 {\n\t\tfor _, e := range response.Errors {\n\t\t\tlog.Warnf(\"API ERROR: %s %s %s\", e.Reference, e.Field, e.Message)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc CreateSuccessResponse(data interface{}, status ...int) Response {\n\tfinalStatus := http.StatusOK\n\tif len(status) > 0 {\n\t\tfinalStatus = status[0]\n\t}\n\n\treturn Response{\n\t\tData:   data,\n\t\tErrors: nil,\n\t\tStatus: finalStatus,\n\t}\n}\n\nfunc CreateAPIErrorsResponse(errors []APIError, status ...int) Response {\n\tfinalStatus := http.StatusInternalServerError\n\tif len(status) > 0 {\n\t\tfinalStatus = status[0]\n\t}\n\n\treturn Response{\n\t\tData:   nil,\n\t\tErrors: errors,\n\t\tStatus: finalStatus,\n\t}\n}\n\nfunc CreateAPIErrorResponse(err APIError, status ...int) Response {\n\tfinalStatus := http.StatusInternalServerError\n\tif len(status) > 0 {\n\t\tfinalStatus = status[0]\n\t}\n\n\treturn Response{\n\t\tData:   nil,\n\t\tErrors: []APIError{err},\n\t\tStatus: finalStatus,\n\t}\n}\n\nfunc CreateErrorResponse(err error, status ...int) Response {\n\tfinalStatus := http.StatusInternalServerError\n\tif len(status) > 0 {\n\t\tfinalStatus = status[0]\n\t}\n\n\treturn Response{\n\t\tData:   nil,\n\t\tErrors: []APIError{{Message: err.Error()}},\n\t\tStatus: finalStatus,\n\t}\n}\n\nfunc RespondSuccess(w http.ResponseWriter, r *http.Request, data interface{}, status ...int) {\n\trsp := CreateSuccessResponse(data, status...)\n\t_ = render.Render(w, r, &rsp)\n}\n\nfunc RespondAPIError(w http.ResponseWriter, r *http.Request, err APIError, status ...int) {\n\trsp := CreateAPIErrorResponse(err, status...)\n\t_ = render.Render(w, r, &rsp)\n}\n\nfunc RespondError(w http.ResponseWriter, r *http.Request, err error, status ...int) {\n\trsp := CreateErrorResponse(err, status...)\n\t_ = render.Render(w, r, &rsp)\n}\n\nfunc RespondValidationError(w http.ResponseWriter, r *http.Request, err error, status ...int) {\n\tif _, ok := err.(*validator.InvalidValidationError); ok {\n\t\tRespondError(w, r, err, status...)\n\t\treturn\n\t}\n\n\tvalidationErrors, ok := err.(validator.ValidationErrors)\n\tif !ok {\n\t\tRespondError(w, r, err, status...)\n\t\treturn\n\t}\n\n\tvar apiErrors []APIError\n\tfor _, fieldError := range validationErrors {\n\n\t\tapiError := APIError{\n\t\t\tField:   fieldError.Field(),\n\t\t\tMessage: fieldError.Error(),\n\t\t}\n\t\tapiErrors = append(apiErrors, apiError)\n\t}\n\n\trsp := CreateAPIErrorsResponse(apiErrors, status...)\n\t_ = render.Render(w, r, &rsp)\n}\n"),
	}
	file8 := &embedded.EmbeddedFile{
		Filename:    "server/routes.go.tpl",
		FileModTime: time.Unix(1608826333, 0),

		Content: string("/*Generated code do not modify it*/\npackage server\n\nimport (\n\"{{.apiSpec.Module}}/gen/entities\"\n\"context\"\n\"fmt\"\n\"github.com/go-chi/chi\"\n\"github.com/go-playground/validator/v10\"\n\"github.com/go-chi/render\"\n\"net/http\"\n)\n\nvar validate = validator.New()\n\ntype controller interface {\n{{- range $i, $endpoint := .apiSpec.Endpoints}}\n    {{$endpoint.Name}}(w http.ResponseWriter, r *http.Request\n    {{- range $i, $param := $endpoint.GetURLParams}}, {{$param}} entities.{{toPascalCase $param}} {{- end}}\n    {{- if $endpoint.BodyFields}}, data {{$endpoint.Name}}Request{{- end}})\n{{- end}}\n}\n\ntype modelResolver interface {\n{{- range $i, $model := .apiSpec.Models}}\n    Find{{$model.Name}}ByUuid(ctx context.Context, uuid string) (entities.{{$model.Name}}, bool, error)\n{{- end}}\n}\n\ntype Handler struct {\nController controller\nModelResolver modelResolver\n}\n\nfunc (h* Handler) RegisterUnauthorizedRoutes(r chi.Router) {\n{{- range $i, $endpoint := .apiSpec.Endpoints}}\n    {{- if not $endpoint.Auth}}\n        r.{{$endpoint.Method}}(\"{{$endpoint.Path}}\", h.{{$endpoint.Name}})\n    {{- end}}\n{{- end}}\n}\n\nfunc (h* Handler) RegisterAuthorizedRoutes(r chi.Router) {\n{{- range $i, $endpoint := .apiSpec.Endpoints}}\n    {{- if $endpoint.Auth}}\n        r.{{$endpoint.Method}}(\"{{$endpoint.Path}}\", h.{{$endpoint.Name}})\n    {{- end}}\n{{- end}}\n}\n\n{{- range $i, $endpoint := .apiSpec.Endpoints}}\n    {{if $endpoint.BodyFields}}\n        type {{$endpoint.Name}}Request struct {\n        {{- range $i, $bodyField := $endpoint.BodyFields}}\n            {{toPascalCase $bodyField.Name}} {{$bodyField.Type}} `json:\"{{$bodyField.Name}}\" validate:\"{{join $bodyField.Validators}}\"`\n        {{- end}}\n        }\n\n        func (d *{{$endpoint.Name}}Request) Bind(*http.Request) error {\n        return validate.Struct(d)\n        }\n    {{- end}}\n\n    func (h* Handler) {{$endpoint.Name}}(w http.ResponseWriter, r *http.Request) {\n    {{- range $i, $param := $endpoint.GetURLParams}}\n        {{toCamelCase $param}}Uuid := chi.URLParam(r, \"{{$param}}\")\n        {{toCamelCase $param}}, ok, err := h.ModelResolver.Find{{toPascalCase $param}}ByUuid(r.Context(), {{toCamelCase $param}}Uuid)\n        if err != nil {\n        RespondError(w, r, fmt.Errorf(\"failed to get {{toCamelCase $param}}: %w\", err))\n        return\n        } else if !ok {{- if gt $i 0}} || {{toCamelCase (index $endpoint.GetURLParams 0)}}.Id != {{toCamelCase $param}}.{{toPascalCase (index $endpoint.GetURLParams 0)}}Id {{- end}} {\n        RespondError(w, r, fmt.Errorf(\"{{toCamelCase $param}} not found\"), http.StatusNotFound)\n        return\n        }\n    {{end}}\n\n    {{- if $endpoint.BodyFields}}\n        data := {{$endpoint.Name}}Request{}\n        if err := render.Bind(r, &data); err != nil {\n        RespondValidationError(w, r, err, http.StatusBadRequest)\n        return\n        }\n    {{- end}}\n\n    h.Controller.{{$endpoint.Name}}(w, r\n    {{- range $i, $param := $endpoint.GetURLParams}}, {{$param}} {{- end}}\n    {{- if $endpoint.BodyFields}}, data {{- end}})\n    }\n{{- end}}\n"),
	}
	file9 := &embedded.EmbeddedFile{
		Filename:    "server/server.go.tpl",
		FileModTime: time.Unix(1608823120, 0),

		Content: string("/*Generated code do not modify it*/\npackage server\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Server struct {\n\tserver   *http.Server\n\tserverWG *sync.WaitGroup\n}\n\nfunc NewServer() *Server {\n\treturn &Server{\n\t\tserver:   &http.Server{},\n\t\tserverWG: &sync.WaitGroup{},\n\t}\n}\n\nfunc (s *Server) SetHandler(router http.Handler) *Server {\n\ts.server.Handler = router\n\treturn s\n}\n\nfunc (s *Server) SetPort(port int64) *Server {\n\ts.server.Addr = fmt.Sprintf(\":%d\", port)\n\treturn s\n}\n\nfunc (s *Server) Start() {\n\tgo func() {\n\t\ts.serverWG.Add(1)\n\t\tdefer s.serverWG.Done()\n\n\t\tlog.Infof(\"Starting server at address %s\", s.server.Addr)\n\t\tif err := s.server.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tlog.Errorf(\"Server failed: %w\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Stop(wg *sync.WaitGroup) {\n\tif wg != nil {\n\t\twg.Add(1)\n\t\tdefer wg.Done()\n\t}\n\n\tlog.Infof(\"stopping the http server\")\n\terr := s.server.Shutdown(context.Background())\n\tif err != nil {\n\t\tlog.Errorf(\"failed to shutdown the http server: %s\", err)\n\t}\n\n\ts.serverWG.Wait()\n}\n"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1608827396, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir2 := &embedded.EmbeddedDir{
		Filename:   "entities",
		DirModTime: time.Unix(1608829508, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file3, // "entities/entity.go.tpl"

		},
	}
	dir4 := &embedded.EmbeddedDir{
		Filename:   "logs",
		DirModTime: time.Unix(1608827132, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file5, // "logs/logs.go.tpl"

		},
	}
	dir6 := &embedded.EmbeddedDir{
		Filename:   "server",
		DirModTime: time.Unix(1608826333, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file7, // "server/response.go.tpl"
			file8, // "server/routes.go.tpl"
			file9, // "server/server.go.tpl"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{
		dir2, // "entities"
		dir4, // "logs"
		dir6, // "server"

	}
	dir2.ChildDirs = []*embedded.EmbeddedDir{}
	dir4.ChildDirs = []*embedded.EmbeddedDir{}
	dir6.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`../templates`, &embedded.EmbeddedBox{
		Name: `../templates`,
		Time: time.Unix(1608827396, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"":         dir1,
			"entities": dir2,
			"logs":     dir4,
			"server":   dir6,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"entities/entity.go.tpl": file3,
			"logs/logs.go.tpl":       file5,
			"server/response.go.tpl": file7,
			"server/routes.go.tpl":   file8,
			"server/server.go.tpl":   file9,
		},
	})
}
